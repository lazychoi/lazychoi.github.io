---
title: 완주하지 못한 선수
date: 2022/11/03
updated: last-modified
---

## 접근 과정

1. 미완주자가 한 명이니 한 명 이름만 반환한다.
1. in 연산자를 쓰면 될 것 같은데 동명이인이 걸린다.
1. 참가자 명단의 동명이인 수와 완주자 명단의 수가 일치하지 않으면 그 만큼은 완주하지 못한 것 
1. 참가자명단.count(이름) != 완주자명단.count(이름)일 경우 그 이름을 반환 -> **시간 초과로 실패**
1. 완주자 이름을 for로 돌려 참가자 명단에서 삭제. 삭제 안 된 사람을 출력한다. -> **시간 초과로 실패**

[https://school.programmers.co.kr/learn/courses/30/lessons/42576](https://school.programmers.co.kr/learn/courses/30/lessons/42576)


```{python}
# 시간 초과로 실패
p = ["eden", "kiki", "kiki"]
c = ["eden", "kiki"]

for person in c:
    if person in p:
        p.remove(person)
print(p.pop())
```

```{python}
# 시간 초과로 실패
p = ["leo", "kiki", "eden"]
c = ["eden", "kiki"]

for person in p:
    if c.count(person) != p.count(person):
        print(person)
```

1. 리스트를 정렬하고
1. for문을 len(participant) - 1까지 반복한다. 왜냐하면, completion의 크기가 1 작으니 참가자 마지막 요소 앞까지만 비교한다.
1. 인덱스가 같은데 값이 다르면 미완주자다. 여기서 break를 넣거나 return 하여 더 이상 반복하지 않도록 한다. 그렇지 않으면 뒤의 값으로 대체된다.
1. 모든 인덱스가 같으면 참가자명단에서 비교하지 않고 남은 맨 마지막 요소가 미완주자가 된다.

```{python}
p = ["a", "kiki", "eden",  'hoa', "kiki", "kiki"]
c = ["kiki", "eden", "kiki", "kiki", 'hoa']

p.sort()
c.sort()

answer = ''
for i in range(len(p) -1 ):
    if p[i] != c[i]:
        answer = p[i]
        break
if answer == '':
    print(p[-1])
else:
    print(answer)

# 함수로 만들면 조금 더 간단하다
def solution(p, c):
    p.sort()
    c.sort()
    answer = ''
    for i in range(len(p) -1):
        if p[i] != c[i]:
            return p[i]
    return p[-1]

```

## 다른 사람 코드

위의 count 함수를 쓴 것과 알고리즘은 같다. 다른 점은 collections 객체의 Counter() 메서드를 쓰면 속도가 빠른가 보다. 그리고 for문을 돌리지 않아도 된다. 기억해 두자. 언젠가 쓸지도 모르니.

```{python}
import collections

answer = collections.Counter(p) - collections.Counter(c)
print(list(answer.keys())[0])

print(answer) # Counter() 반환값은 dict. 키에 해당하는 문자를 모르니 리스트로 변환해서 첫 번째 요소를 출력함
```
