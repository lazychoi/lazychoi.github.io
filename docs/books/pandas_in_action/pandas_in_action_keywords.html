<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="kr" xml:lang="kr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2022-10-21">

<title>👀 - Pandas in Action 키워드</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">👀</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">Home</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../books.html">읽은 책</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../pkm.html">지식관리</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../de.html">개발환경</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../review.html">오답노트</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../visualization.html">시각화</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog/index.html">블로그</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">Contact</a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/lazychoi"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#series" id="toc-series" class="nav-link active" data-scroll-target="#series">Series</a>
  <ul class="collapse">
  <li><a href="#생성-pd.seriesdatanone-indexnone-dtypenone" id="toc-생성-pd.seriesdatanone-indexnone-dtypenone" class="nav-link" data-scroll-target="#생성-pd.seriesdatanone-indexnone-dtypenone">생성: pd.Series(data=None, index=None, dtype=None)</a></li>
  <li><a href="#series-속성" id="toc-series-속성" class="nav-link" data-scroll-target="#series-속성">Series 속성</a></li>
  <li><a href="#series-메서드" id="toc-series-메서드" class="nav-link" data-scroll-target="#series-메서드">Series 메서드</a></li>
  <li><a href="#주요-메서드" id="toc-주요-메서드" class="nav-link" data-scroll-target="#주요-메서드">주요 메서드</a></li>
  </ul></li>
  <li><a href="#dataframe" id="toc-dataframe" class="nav-link" data-scroll-target="#dataframe">DataFrame</a>
  <ul class="collapse">
  <li><a href="#생성" id="toc-생성" class="nav-link" data-scroll-target="#생성">생성</a></li>
  <li><a href="#속성" id="toc-속성" class="nav-link" data-scroll-target="#속성">속성</a></li>
  <li><a href="#메서드" id="toc-메서드" class="nav-link" data-scroll-target="#메서드">메서드</a></li>
  <li><a href="#정렬-및-인덱스" id="toc-정렬-및-인덱스" class="nav-link" data-scroll-target="#정렬-및-인덱스">정렬 및 인덱스</a></li>
  <li><a href="#열과-행-선택-및-이름-바꾸기" id="toc-열과-행-선택-및-이름-바꾸기" class="nav-link" data-scroll-target="#열과-행-선택-및-이름-바꾸기">열과 행 선택 및 이름 바꾸기</a></li>
  </ul></li>
  <li><a href="#데이터셋-변환으로-메모리-최적화" id="toc-데이터셋-변환으로-메모리-최적화" class="nav-link" data-scroll-target="#데이터셋-변환으로-메모리-최적화">데이터셋 변환으로 메모리 최적화</a></li>
  <li><a href="#dataframe-필터링" id="toc-dataframe-필터링" class="nav-link" data-scroll-target="#dataframe-필터링">Dataframe 필터링</a></li>
  <li><a href="#결측값-다루기" id="toc-결측값-다루기" class="nav-link" data-scroll-target="#결측값-다루기">결측값 다루기</a></li>
  <li><a href="#중복값-다루기" id="toc-중복값-다루기" class="nav-link" data-scroll-target="#중복값-다루기">중복값 다루기</a></li>
  <li><a href="#장-텍스트-데이터-다루기" id="toc-장-텍스트-데이터-다루기" class="nav-link" data-scroll-target="#장-텍스트-데이터-다루기">6장 텍스트 데이터 다루기</a></li>
  <li><a href="#장-멀티-인덱스-데이터프레임" id="toc-장-멀티-인덱스-데이터프레임" class="nav-link" data-scroll-target="#장-멀티-인덱스-데이터프레임">7장 멀티 인덱스 데이터프레임</a>
  <ul class="collapse">
  <li><a href="#멀티-인덱스-멀티-컬럼-생성" id="toc-멀티-인덱스-멀티-컬럼-생성" class="nav-link" data-scroll-target="#멀티-인덱스-멀티-컬럼-생성">멀티 인덱스, 멀티 컬럼 생성</a></li>
  <li><a href="#멀티-인덱스-정렬---데이터가-아니라-인덱스-이름-순으로-정렬" id="toc-멀티-인덱스-정렬---데이터가-아니라-인덱스-이름-순으로-정렬" class="nav-link" data-scroll-target="#멀티-인덱스-정렬---데이터가-아니라-인덱스-이름-순으로-정렬">멀티 인덱스 정렬 &lt;- 데이터가 아니라 인덱스 이름 순으로 정렬</a></li>
  <li><a href="#멀티-인덱스-행-열-선택" id="toc-멀티-인덱스-행-열-선택" class="nav-link" data-scroll-target="#멀티-인덱스-행-열-선택">멀티 인덱스 행, 열 선택</a></li>
  <li><a href="#멀티-인덱스-재설정" id="toc-멀티-인덱스-재설정" class="nav-link" data-scroll-target="#멀티-인덱스-재설정">멀티 인덱스 재설정</a></li>
  </ul></li>
  <li><a href="#장-재구성과-피벗" id="toc-장-재구성과-피벗" class="nav-link" data-scroll-target="#장-재구성과-피벗">10장 재구성과 피벗</a>
  <ul class="collapse">
  <li><a href="#피벗-테이블-생성" id="toc-피벗-테이블-생성" class="nav-link" data-scroll-target="#피벗-테이블-생성">피벗 테이블 생성</a></li>
  <li><a href="#인덱스-레벨-스택과-언스택" id="toc-인덱스-레벨-스택과-언스택" class="nav-link" data-scroll-target="#인덱스-레벨-스택과-언스택">인덱스 레벨 스택과 언스택</a></li>
  <li><a href="#melting-피벗-해제" id="toc-melting-피벗-해제" class="nav-link" data-scroll-target="#melting-피벗-해제">melting, 피벗 해제</a></li>
  </ul></li>
  <li><a href="#장-groupby-객체" id="toc-장-groupby-객체" class="nav-link" data-scroll-target="#장-groupby-객체">9장 GroupBy 객체</a></li>
  <li><a href="#장-병합-조인-연결" id="toc-장-병합-조인-연결" class="nav-link" data-scroll-target="#장-병합-조인-연결">10장 병합, 조인, 연결</a>
  <ul class="collapse">
  <li><a href="#조인" id="toc-조인" class="nav-link" data-scroll-target="#조인">조인</a></li>
  </ul></li>
  <li><a href="#장-날짜-시간" id="toc-장-날짜-시간" class="nav-link" data-scroll-target="#장-날짜-시간">11장 날짜, 시간</a>
  <ul class="collapse">
  <li><a href="#파이썬-datetime-모듈" id="toc-파이썬-datetime-모듈" class="nav-link" data-scroll-target="#파이썬-datetime-모듈">파이썬 datetime 모듈</a></li>
  <li><a href="#판다스-timestamp-객체" id="toc-판다스-timestamp-객체" class="nav-link" data-scroll-target="#판다스-timestamp-객체">판다스 Timestamp 객체</a></li>
  <li><a href="#datetimeproperties-객체" id="toc-datetimeproperties-객체" class="nav-link" data-scroll-target="#datetimeproperties-객체">DatetimeProperties 객체</a></li>
  <li><a href="#일정-시간의-덧셈과-뺄셈-dateoffset" id="toc-일정-시간의-덧셈과-뺄셈-dateoffset" class="nav-link" data-scroll-target="#일정-시간의-덧셈과-뺄셈-dateoffset">일정 시간의 덧셈과 뺄셈 DateOffset</a></li>
  <li><a href="#timedelta-객체" id="toc-timedelta-객체" class="nav-link" data-scroll-target="#timedelta-객체">Timedelta 객체</a></li>
  </ul></li>
  <li><a href="#가져오기-내보내기" id="toc-가져오기-내보내기" class="nav-link" data-scroll-target="#가져오기-내보내기">가져오기, 내보내기</a>
  <ul class="collapse">
  <li><a href="#json" id="toc-json" class="nav-link" data-scroll-target="#json">json</a></li>
  <li><a href="#csv" id="toc-csv" class="nav-link" data-scroll-target="#csv">csv</a></li>
  <li><a href="#excel" id="toc-excel" class="nav-link" data-scroll-target="#excel">excel</a></li>
  </ul></li>
  <li><a href="#장-시각화" id="toc-장-시각화" class="nav-link" data-scroll-target="#장-시각화">14장 시각화</a></li>
  <li><a href="#fake-데이터프레임-만들기" id="toc-fake-데이터프레임-만들기" class="nav-link" data-scroll-target="#fake-데이터프레임-만들기">fake 데이터프레임 만들기</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Pandas in Action 키워드</h1>
</div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 21, 2022</p>
    </div>
  </div>
    
  </div>
  

</header>

<section id="series" class="level2">
<h2 class="anchored" data-anchor-id="series">Series</h2>
<section id="생성-pd.seriesdatanone-indexnone-dtypenone" class="level3">
<h3 class="anchored" data-anchor-id="생성-pd.seriesdatanone-indexnone-dtypenone">생성: pd.Series(data=None, index=None, dtype=None)</h3>
<ul>
<li>생성자: data, index, dtype</li>
<li>data: 딕셔너리, 리스트, 튜플 자료형, numpy ndarray. but 집합 자료형은 안 됨(순서, 연관이 없기 때문)</li>
<li>index 사용자 정의</li>
<li>dtype 지정으로 형변환</li>
<li>결측값 입력: np.nan</li>
</ul>
</section>
<section id="series-속성" class="level3">
<h3 class="anchored" data-anchor-id="series-속성">Series 속성</h3>
<ul>
<li>시리즈.index, 시리즈.dtype, 시리즈.size, 시리즈.shape, 시리즈.values</li>
<li>시리즈.is_unique, <strong>시리즈.is_monotonic</strong></li>
</ul>
</section>
<section id="series-메서드" class="level3">
<h3 class="anchored" data-anchor-id="series-메서드">Series 메서드</h3>
<ul>
<li>시리즈.head([n]), 시리즈.tail([n])</li>
<li>수학 연산:
<ul>
<li>인덱스(라벨)가 같은 것끼리 연산.</li>
<li>결측값 무시</li>
<li>시리즈.count(), 시리즈.sum(skipna=True, min_count=0), 시리즈.product(skipna=True, min_count=0)</li>
<li>시리즈.mean(), 시리즈.median(), 시리즈.std(), 시리즈.max(), 시리즈.min()</li>
<li><strong>시리즈.cumsum(skipna=True)</strong>, <strong>시리즈.pct_change([fill_method=])</strong></li>
<li>시리즈.describe(), 시리즈.sample(), 시리즈.unique(), 시리즈.nunique()</li>
<li>산술 연산:</li>
<li>NaN과 연산할 때 NaN 반환</li>
<li>’+, -, *, /, //, %, ==, !=’ 연산자</li>
<li>시리즈.add([스칼라 or 시리즈]), 시리즈.sub([스칼라 or 시리즈]), 시리즈.subtract([스칼라 or 시리즈]), 시리즈.mul([스칼라 or 시리즈]), 시리즈.multiply([스칼라 or 시리즈]), 시리즈.div([스칼라 or 시리즈]), 시리즈.divide([스칼라 or 시리즈]), 시리즈.floordiv([스칼라 or 시리즈]), 시리즈.mod([스칼라 or 시리즈]), 시리즈.eq([스칼라 or 시리즈]), 시리즈.ne([스칼라 or 시리즈])</li>
</ul></li>
<li>시리즈를 파이썬 함수 인자로 전달 가능: len(시리즈), list(시리즈), dict(시리즈), ‘값’ [not] in 시리즈.values</li>
</ul>
<p>주의!!!</p>
<ul>
<li>np.nan == np.nan =&gt; False</li>
<li>len(시리즈) =&gt; NaN 포함</li>
<li>NaT: not a time</li>
</ul>
</section>
<section id="주요-메서드" class="level3">
<h3 class="anchored" data-anchor-id="주요-메서드">주요 메서드</h3>
<ul>
<li>아래 모든 메서드는 새로운 시리즈 반환.</li>
<li>자신을 바꾸려면 inplace=True 옵션 추가(None 반환) =&gt; 성능 이점 없으니 사용하지 말 것</li>
<li>pd.read_csv(‘csv파일명’):
<ul>
<li>index_col=‘열이름’</li>
<li>squeeze=True : 데이터프레임 자료형을 시리즈 자료형으로 변환. but deprecated</li>
<li><strong>parse_dates</strong>=[‘열이름’] : 날짜 형식의 문자열 -&gt; 날짜 자료형</li>
<li>usecols=[‘열이름, ’열이름’] : 가져올 열이름 지정. 시리즈로 가져올 때는 최대 2개</li>
</ul></li>
<li>value 기준 정렬:
<ul>
<li>시리즈.sort_values(), 시리즈.sort_values(ascending=False)</li>
<li>na_position=‘last/first’: NaN 배치(default=last)</li>
</ul></li>
<li>index 기준 정렬: 날짜 인덱스일 때 주로 사용
<ul>
<li>시리즈.sort_index(), 시리즈.sort_index(ascending=False)</li>
</ul></li>
<li>결측값 제거: 시리즈.dropna()</li>
<li>최고[저]값 n개: 시리즈.nlargest(n), 시리즈.nsmallest(n)</li>
<li>값 별 개수: 시리즈.value_counts()
<ul>
<li>ascending=False/True</li>
<li><strong>normalize</strong>=False/True</li>
<li><strong>bins</strong>=[] : 구간을 정해 개수 세기. eg. bins = 5 or [0, 200, 400, 600, 800]</li>
<li><strong>sort=False</strong> : 인덱스 순으로 출력</li>
<li>dropna=False: NaN 개수도 세기</li>
</ul></li>
<li>반올림: 시리즈.round(n) n=출력할 소숫점 자리수</li>
<li>시리즈.apply(함수) : 시리지의 각 값에 대해 한 번씩 함수를 호출하고 반환값을 시리즈로 구성해 새 시리즈를 반환</li>
</ul>
</section>
</section>
<section id="dataframe" class="level2">
<h2 class="anchored" data-anchor-id="dataframe">DataFrame</h2>
<section id="생성" class="level3">
<h3 class="anchored" data-anchor-id="생성">생성</h3>
<ul>
<li>중복된 행, 중복된 열 인덱스를 허용하지만 가능한 고유값으로 하는 게 좋음</li>
<li>pd.DataFrame(data)
<ul>
<li>dictionary, list, tuple, ndarray (iterable) -&gt; DataFrame</li>
<li>columns = [‘col1’,‘col2’,…]</li>
</ul></li>
</ul>
</section>
<section id="속성" class="level3">
<h3 class="anchored" data-anchor-id="속성">속성</h3>
<ul>
<li>df변수.index -&gt; RangeIndex(start, end, steps) 반환</li>
<li>df변수.columns -&gt; Index 반환</li>
<li>df변수.shape</li>
<li>df변수.size(NaN 포함) cf.&nbsp;NaN 포함한 개수 : df변수.count()</li>
</ul>
</section>
<section id="메서드" class="level3">
<h3 class="anchored" data-anchor-id="메서드">메서드</h3>
<ul>
<li>df변수.sum([numeric_only=True]), df변수.mead([numeric_only=True]), df변수.median([numeric_only=True]), df변수.mode([numeric_only=True]), df변수.std([numeric_only=True])</li>
<li>df변수.max(), df변수.min()</li>
<li><strong>df변수.nunique()</strong> : 열 별로 고윳값 개수 나타내는 Series 반환</li>
<li><strong>df변수.nlargest</strong>(n, columns=[‘col1’, ‘col2’]), df변수.smallest()</li>
</ul>
</section>
<section id="정렬-및-인덱스" class="level3">
<h3 class="anchored" data-anchor-id="정렬-및-인덱스">정렬 및 인덱스</h3>
<ul>
<li>한 열 기준으로 정렬: df변수.sort_values(‘열이름’, ascending=True/False)</li>
<li>여러 열 기준으로 정렬: df변수.sort_values([‘열이름’, ‘열이름’, …], ascending=True/False)</li>
<li>각 열을 다른 순서로 정렬: df변수.sort_values([‘열이름’, ‘열이름’, …], ascending=[True, False])</li>
<li>행 인덱스 기준으로 정렬: df변수.sort_index(ascending=True/False)</li>
<li>열 인덱스 기준으로 정렬: df변수.sort_index(axis=‘columns’, ascending=True/False) or df변수.sort_index(axis=1)</li>
<li>df변수 정렬을 최초 상태로 되돌리기: df변수 = df변수.sort_index()</li>
<li>새 인덱스 설정: df변수 = df변수.set_index(‘열이름’)</li>
<li>인덱스를 일반 컬럼로 바꾸기: df변수.reset_index()</li>
<li>기존 인덱스를 일반 컬럼으로 바꾸고 새 인덱스 설정: df변수 = df변수.reset_index().set_index(‘열이름’)</li>
</ul>
</section>
<section id="열과-행-선택-및-이름-바꾸기" class="level3">
<h3 class="anchored" data-anchor-id="열과-행-선택-및-이름-바꾸기">열과 행 선택 및 이름 바꾸기</h3>
<ul>
<li>열 선택
<ul>
<li>다중 열 선택: df변수[‘열이름’], df변수[[‘열이름’,‘열이름’,…]]</li>
<li>데이터 유형에 따라 열 선택(eg. 문자형 열만 선택): df변수.select_dtypes(include=‘object’)</li>
<li>데이터 유형에 따라 열 선택(eg. 문자형 및 정수 열 제외한 모든 열 선택): df변수.select_dtypes(exclude=[‘object’, ‘int’])</li>
</ul></li>
<li>행 선택
<ul>
<li>레이블 선택: df변수.loc[[‘행이름’, ‘행이름’, …]]</li>
<li>슬라이싱 활용: df변수.loc[‘행이름’ : ], df변수.loc[ : ‘행이름’], df변수.loc[‘행이름’ : ‘행이름’]</li>
<li>인덱스 위치 선택: df변수.iloc[n], df변수.iloc[n:m], df변수.iloc[n:m:step], df변수.iloc[[m, n, o, …]]</li>
</ul></li>
<li>열, 행 함께 고려하여 선택
<ul>
<li>셀 값: df변수.loc[‘행이름’, ‘열이름’], df변수.iloc[m, n], df변수.at[‘행이름’, ‘열이름’], df변수.iat[행번호, 열번호]</li>
<li>한 행의 여러 컬럼 값 선택: df변수.loc[‘행이름’, [‘열이름’, ‘컬러명’]], df변수[‘행이름’, ‘열이름’:‘열이름’], df변수.iloc[n, [m, o]], df변수.iloc[n, [m : o]]</li>
<li>여러 행의 여러 컬럼 값 선택: df변수.loc[[‘행이름’, ‘행이름’], [‘열이름’, ‘열이름’]]</li>
</ul></li>
<li>이름 바꾸기
<ul>
<li>열이름 가져오기: df변수.columns</li>
<li>열이름 일부 변경: df변수 = df변수.rename(columns = {‘구이름’:‘새이름’})</li>
<li>행이름 일부 변경: df변수 = df변수.rename(index = {‘구이름’:‘새이름’})</li>
</ul></li>
<li>열 삭제
<ul>
<li>df변수 = df변수.drop(labels=‘열이름’, axis=‘columns’)</li>
</ul></li>
</ul>
</section>
</section>
<section id="데이터셋-변환으로-메모리-최적화" class="level2">
<h2 class="anchored" data-anchor-id="데이터셋-변환으로-메모리-최적화">데이터셋 변환으로 메모리 최적화</h2>
<ul>
<li>최적의 데이터 유형: 가장 적은 메모리 사용 or 가장 많은 유틸리티 제공 데이터 유형</li>
<li>날짜/시간 유형으로 변환: pd.read_csv(parse_dates=[‘열이름’])</li>
<li>데이터셋의 용량 확인: df변수.info()</li>
<li>데이터 형변환: df변수[‘열이름’] = df변수[‘열이름’].astype(자료형)</li>
<li>NaN이 있으면 정수값만 있어도 float64 -&gt; NaN을 정수로 바꾼 뒤 정수형으로 변환: df변수[‘열이름’].fillna(0).astype(int)</li>
<li>소수의 고유값으로 구성된 열 -&gt; 범주형: df변수[‘gender’] = df변수[‘gender’].astype(‘category’)</li>
</ul>
</section>
<section id="dataframe-필터링" class="level2">
<h2 class="anchored" data-anchor-id="dataframe-필터링">Dataframe 필터링</h2>
<ul>
<li>반환되는 boolean 시리즈 활용</li>
<li><code>==</code>(eq), <code>!=</code>(ne), <code>&lt;</code>(lt), <code>&lt;=</code>(le), <code>&gt;</code>(gt), <code>&gt;=</code>(ge), <code>&amp;</code>, <code>|</code>, <code>~</code></li>
<li>여러 개의 문자열이 포함된 행 필터링(or): df변수[‘열이름’].isin([‘찾을 문자열’, ‘찾을 문자열’, …])</li>
<li>범위 내의 데이터 필터링(숫자, 날짜, 문자): df변수[‘열이름’].between(시작, 끝)</li>
<li>결측값만 필터링: df변수[‘열이름’].isnull()</li>
<li>결측값이 아닌 행만 필터링: df변수[‘열이름’].notnull()</li>
</ul>
</section>
<section id="결측값-다루기" class="level2">
<h2 class="anchored" data-anchor-id="결측값-다루기">결측값 다루기</h2>
<ul>
<li>결측값이 포함된 행 삭제: df변수.dropna(how=‘any/all’)</li>
<li><strong>특정 열에 결측값이 있는 행 삭제</strong>: df변수.dropna(subset=[‘열이름’])</li>
<li>비결측값이 최소 n개인 행만 남김: df변수.dropna(thresh = n)</li>
<li>결측값를 특정값으로 바꾸기: df변수.fillna(바꿀값)</li>
</ul>
</section>
<section id="중복값-다루기" class="level2">
<h2 class="anchored" data-anchor-id="중복값-다루기">중복값 다루기</h2>
<ul>
<li>반환되는 boolean 시리즈 활용</li>
<li><a href="../../books/pandas_in_action/duplicated.html">duplicated</a></li>
<li>열에서 이전에 한 번이라도 본 적이 있는 값은 모두 True 표시: df변수[‘열이름’].duplicated()</li>
<li>특정 열에서 고유한 값의 첫 번째 행만 필터링: df변수[ ~df변수[‘열이름’].duplicated() ]</li>
<li>&lt;- duplicated()는 동일한 값 중 두번째 값부터 True를 반환하기 때문에 반대로 뒤집으면(~) 중복되지 않은 값 중 첫 번째 행만 출력됨</li>
<li>행의 모든 값이 일치하는 행 제거: df변수.drop_duplicates()</li>
<li>특정 열에서 중복값 제거(특정 값이 처음 나타나는 행만 유지): df변수.drop_duplicates(subset=[‘열이름’])</li>
<li>특정 열에서 중복값 제거(특정 값이 마지막 나타나는 행만 유지): df변수.drop_duplicates(subset=[‘열이름’], keep=’last)</li>
<li>특정 열에서 중복값 모두 제거(첫번째나 마지막 값도 삭제): df변수.drop_duplicates(subset=[‘열이름’], keep=False)</li>
</ul>
</section>
<section id="장-텍스트-데이터-다루기" class="level2">
<h2 class="anchored" data-anchor-id="장-텍스트-데이터-다루기">6장 텍스트 데이터 다루기</h2>
<ul>
<li>랭글링(wrangling), 먼징(munging): 데이터를 정리하는 과정</li>
<li>시리즈 객체의 str 속성 사용하면 강력한 문자열 처리 메서드를 제공하는 StringMethods 객체에 접근 가능: df변수[‘object 컬럼’].str</li>
<li>공백 제거: df변수[‘object 컬럼’] = df변수[‘object 컬럼’].str.strip()/lstrip()/rstrip()</li>
<li>모든 컬럼에 문자열 함수 적용: for column in df변수.columns: ; df[column] = df[column].str.strip()</li>
<li>df변수[‘object 컬럼’].str.upper()/lower()/capitalize()/title()</li>
<li>df변수[‘object 컬럼’].str.replace()</li>
<li>슬라이싱은 파이썬과 같음: df변수[‘object 컬럼’].str[시작인덱스:끝인덱스]</li>
<li>특정 단어가 포함된 행 필터링: has_pizza = df변수[‘object 컬럼’].str.lower().str.contains(‘pizza’) ; df변수[has_pizza] &lt;- 대소문자 구분 없애기 위해 먼저 소문자로 변환</li>
<li>특정 문자로 시작하는 단어 찾기: df변수[‘object 컬럼’].str.lower().str.startstwith(‘문자’)</li>
<li>특정 문자로 끝나는 단어 찾기: df변수[‘object 컬럼’].str.lower().str.endstwith(‘문자’)</li>
<li>문자열 크기: df변수[‘object 컬럼’].str.len()</li>
<li>문자열 분할 개수 지정: df변수[‘object 컬럼’].str.split(pat = ” “, n = 1) -&gt; 첫 번째 공백만 분할 -&gt; 2개 요소를 지닌 리스트 반환</li>
<li>문자열의 첫 번째 글자만 가져오기: df변수[‘object 컬럼’].str.get(0)</li>
<li>공백으로 분할한 문자의 두 번째 단어만 가져오기: df변수[‘object 컬럼’].str.split(pat = ” “, n = 1).str.get(1)</li>
<li>공백으로 분할한 문자의 마지막 단어만 가져오기: df변수[‘object 컬럼’].str.split(pat = ” “, n = 1).str.get(-1)</li>
<li>공백으로 분할한 문자를 새로운 데이터프레임으로 반환: df변수[‘object 컬럼’].str.split(pat = ” “, n = 1, expand = True)</li>
<li>정규표현식 지원: df변수[‘열이름’].str.repalce(to_replace, value, regex = True)</li>
</ul>
</section>
<section id="장-멀티-인덱스-데이터프레임" class="level2">
<h2 class="anchored" data-anchor-id="장-멀티-인덱스-데이터프레임">7장 멀티 인덱스 데이터프레임</h2>
<section id="멀티-인덱스-멀티-컬럼-생성" class="level3">
<h3 class="anchored" data-anchor-id="멀티-인덱스-멀티-컬럼-생성">멀티 인덱스, 멀티 컬럼 생성</h3>
<ul>
<li>한 열의 값이 다른 열 값의 하위범주인 계층적 데이터 표현에 좋음</li>
<li>MultiIndex : 각 레이블에 여러 값을 보유하는 컨테이너</li>
<li>레벨: 레이블에서 동일한 위치에 있는 값</li>
<li>멀티 row_index = pd.MultiIndex.from_tuples(tuples, names= [‘레벨1’, ’레벨2]) ; pd.DataFrame(row_index=row_index)</li>
<li>멀티 column_index = pd.MultiIndex.from_tuples(tuples) ; pd.DataFrame(columns=column_index)</li>
<li>멀티 인덱스와 헤더가 적용된 csv 파일 불러오기: read_csv(‘파일명’, index_col=[0, 1, 2, …], header = [0, 1, …])</li>
<li>멀티 인덱스 이름 가져오기: df변수.index.names</li>
<li>인덱스 레벨에 해당하는 이름 가져오기: df변수.index.get_level_values(인덱스/이름)</li>
<li>멀티 컬럼에 이름 지정하기: df변수.columns.names = [‘Category’, ‘Subcategory’]</li>
<li>컬럼 레벨에 해당하는 이름 가져오기: df변수.columns.get_level_values(인덱스/이름)</li>
</ul>
</section>
<section id="멀티-인덱스-정렬---데이터가-아니라-인덱스-이름-순으로-정렬" class="level3">
<h3 class="anchored" data-anchor-id="멀티-인덱스-정렬---데이터가-아니라-인덱스-이름-순으로-정렬">멀티 인덱스 정렬 &lt;- 데이터가 아니라 인덱스 이름 순으로 정렬</h3>
<ul>
<li>df변수.sort_index(): 가장 왼쪽의 인덱스부터 오름차순으로 정렬. 내림차순은 ascending=False 매개변수 추가</li>
<li>각 레벨의 정렬 순서를 다르게 지정: df변수.sort_index(ascending = [True, False, True, …])</li>
<li>지정한 레벨만 정렬: df변수.sort_index(level = [인덱스번호/이름, 인덱스번호/이름])</li>
<li>열 정렬: df변수.sort_index(axis = 1/“columns”)</li>
</ul>
</section>
<section id="멀티-인덱스-행-열-선택" class="level3">
<h3 class="anchored" data-anchor-id="멀티-인덱스-행-열-선택">멀티 인덱스 행, 열 선택</h3>
<ul>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html#advanced-indexing-with-hierarchical-index" target="_blank">공식 문서 참고</a></li>
<li>서브카테고리 선택 -&gt; 튜플로 감싼다: df변수[(‘주카테고리명’, ‘서브카테고리명’)]</li>
<li>여러 개의 열 추출 -&gt; 튜플을 대괄호로 감싼다: df변수[ [(‘주카테고리명’, ‘서브카테고리명’), (‘주카테고리명’, ‘서브카테고리명’)] ]</li>
<li>인덱스명으로 행 추출 -&gt; 왼쪽부터 적용: df변수.loc[ (‘인덱스명’, ‘인덱스명’, …)]</li>
<li>행과 열을 이름으로 추출: df변수.loc[ (‘인덱스1레벨’, ‘인덱스2레벨’), (‘주카테고리’, ‘서브카테고리’) ]</li>
<li>df변수.iloc는 레벨에 걸쳐 인덱싱할 수 없다. 단순히 행, 열 순서에 따라 인덱싱, 슬라이싱 한다.</li>
<li>특정 인덱스이름 값이 특정값인 데이터만 출력(eg. City 인덱스가 Seoul인 데이터만 출력): df변수.xs(key = ‘Seoul’, level = ‘City’)</li>
<li>특정 열이름 값이 특정값인 데이터만 출력(eg. Subcategory가 Museum인 데이터만 출력): df변수.xs(axis = ‘columns’, key = ‘Museum’, level = ‘Subcategory’)</li>
<li>xs 메서드에 비연속적인 key, level를 전달할 때는 <strong>튜플로 묶는다</strong>.</li>
</ul>
</section>
<section id="멀티-인덱스-재설정" class="level3">
<h3 class="anchored" data-anchor-id="멀티-인덱스-재설정">멀티 인덱스 재설정</h3>
<ul>
<li>멀티 인덱스를 지정한 순서대로 정렬: df변수.reorder_levels(order = [‘이름1’/번호, ‘이름2’/번호, …])</li>
<li>멀티 인덱스를 새로운 열로 삽입하고 인덱스는 숫자로 대체: df변수.reset_index()
<ul>
<li>col_level = ‘Subcategory’ 열이름을 서브카데고리 레벨에 삽입</li>
<li>col_fill = ‘이름’ 빈 열이름에 지정한 이름 추가</li>
<li>level = ‘인덱스명’ 지정한 인덱스명만 일반 열로 옮김. 인덱스명 여러 개를 리스트로 전달하면 지정한 레벨만 열로 이동.</li>
<li>level = ‘인덱스명’, drop=True 지정한 레벨 삭제</li>
</ul></li>
<li>지정한 멀티 레벨 열을 인덱스로 설정: df변수.set_index(keys = (‘카테고리명’, ‘서브카테고리명’))</li>
</ul>
</section>
</section>
<section id="장-재구성과-피벗" class="level2">
<h2 class="anchored" data-anchor-id="장-재구성과-피벗">10장 재구성과 피벗</h2>
<section id="피벗-테이블-생성" class="level3">
<h3 class="anchored" data-anchor-id="피벗-테이블-생성">피벗 테이블 생성</h3>
<ul>
<li>특정 열(eg. 날짜) 별로 모든 숫자 열의 평균 집계: df변수.pivot_table()
<ul>
<li>index=‘열이름’ : 열이름을 인덱스명으로 사용. 열 리스트를 전달하면 MultiIndex</li>
<li>aggfunc = ‘mean/sum/max/min/std/median/count/size’ : 집계 함수 선택. size = count. 리스트로 여러 개 집계함수 지정[‘sum’, ‘count’]. 딕셔너리 형식으로 열별 다른 집계함수 지정{‘열이름’:‘집계함수’, ‘열이름’:‘집계함수’}</li>
<li>values = ‘열이름’ : 집계 함수를 적용할 열 선택. 여러 열을 선택하려면 리스트로 지정</li>
<li>columns = ‘열이름’ : 입력한 열의 고유값을 열 헤더로 지정</li>
<li>fill_value = 숫자 : NaN을 지정한 값으로 대체</li>
<li>margins = True : 행별, 열별 합계 출력</li>
<li>margins_name = ‘Total’ : 합계 레이블 이름을 ’Total’로 지정</li>
</ul></li>
</ul>
</section>
<section id="인덱스-레벨-스택과-언스택" class="level3">
<h3 class="anchored" data-anchor-id="인덱스-레벨-스택과-언스택">인덱스 레벨 스택과 언스택</h3>
<ul>
<li>df변수.stack() : 열 인덱스 -&gt; 행 인덱스. NaN은 사라짐</li>
<li>df변수.unstack() : 가장 우측 행 인덱스 -&gt; 열 인덱스</li>
</ul>
</section>
<section id="melting-피벗-해제" class="level3">
<h3 class="anchored" data-anchor-id="melting-피벗-해제">melting, 피벗 해제</h3>
<ul>
<li>넓은 데이터셋을 좁은 데이터셋으로 변환하는 과정</li>
<li>df변수.melt()
<ul>
<li>id_vars = ‘식별자 열’</li>
<li>value_vars = ‘피벗 해제되어 새 열에 저장될 열’ 여러 열을 지정하려면 리스트로 묶음 &lt;- 생략 가능. 기본적으로 식별자 열을 제외한 모든 열을 피벗 해제</li>
<li>var_name = ‘열이름’</li>
<li>value_name = ‘열이름’</li>
</ul></li>
<li>열에 있는 리스트 요소를 별도의 행으로 분리: df변수.explode(‘열이름’)</li>
</ul>
</section>
</section>
<section id="장-groupby-객체" class="level2">
<h2 class="anchored" data-anchor-id="장-groupby-객체">9장 GroupBy 객체</h2>
<ul>
<li>df변수.groupby(‘열이름’) -&gt; DataFrameGroupBy 객체 반환. 열이름은 주로 범주형</li>
<li>그룹명에 포함된 모든 행을 데이터프레임으로 반환 : GroupBy객체.get_group(‘그룹명’)</li>
<li>각 그룹의 평균, 합계 등 계산 : GroupBy객체.mean()/sum()/max()/min()</li>
<li>그룹과 행 개수를 알파벳 순서로 나열한 리스트로 구성된 시리즈 반환 : GroupBy객체.size()</li>
<li>그룹을 key로, 그룹에 속한 행을 values 리스트로 구성된 딕셔너리 반환 : GroupBy객체.groups</li>
<li>각 그룹의 첫 번째 행 추출. 부문별 가장 성과 높은 기업을 찾을 때 유용(매출액이 내림차순 정렬되었다면) : GroupBy객체.first()</li>
<li>각 그룹의 마지막 행 추출 : GroupBy객체.last()</li>
<li>각 그룹의 n번째 행 추출 : GroupBy객체.nth(n)</li>
<li>각 그룹에서 n번째까지의 행 가져와 특정 수치형 열 기준으로 내림차순 정렬 : GroupBy객체.head(n)</li>
<li>각 그룹에서 마지막에서 n번째까지의 행 가져와 특정 수치형 열 기준으로 내림차순 정렬 : GroupBy객체.tail(n)</li>
<li>특정 열에 대해 그룹별로 합계 계산 : GroupBy객체[‘열이름’].sum()</li>
</ul>
</section>
<section id="장-병합-조인-연결" class="level2">
<h2 class="anchored" data-anchor-id="장-병합-조인-연결">10장 병합, 조인, 연결</h2>
<ul>
<li>csv 파일 불러올 때 특정 열의 데이터형의 변경 : pd.read_csv(‘파일명’, dtype = {‘열이름’:‘데이터형’})</li>
<li>두 데이터프레임을 세로로 결합(인덱스 번호는 바뀌지 않아 중복됨) : pd.concat([df변수1, df변수2])
<ul>
<li>ignore_index = True : 원본 인덱스를 버리고 새로운 숫자 인덱스 만듦</li>
<li>key = [‘인덱스로 사용할 값’, ‘인덱스로 사용할 값’] : 원본 인덱스를 보존하기 위해 왼쪽에 멀티 인덱스 생성</li>
<li>axis = 1/‘columns’ : 가로로 결합</li>
</ul></li>
<li>두 데이터프레임을 결합할 때 데이터셋이 서로 공유하지 않는 행 레이블과 열 레이블의 교차점에 NaN 입력됨</li>
</ul>
<section id="조인" class="level3">
<h3 class="anchored" data-anchor-id="조인">조인</h3>
<ul>
<li>left join : df변수.merge(df변수, how=‘left’, on=‘연결할 공통열이름’)
<ul>
<li>right_index = True, left_on=‘왼쪽 열이름’ : 왼쪽 df변수의 열과 오른쪽 df변수의 인덱스를 연결할 때</li>
<li>left_index = True, right_on=‘오른쪽 열이름’ : 왼쪽 df변수의 인덱스와 오른쪽 df변수의 열을 연결할 때</li>
</ul></li>
<li>inner join : df변수.merge(df변수, how=‘inner’, on=‘연결할 공통열이름’)</li>
<li>outer join : df변수.merge(df변수, how=‘outer’)
<ul>
<li>left_on=‘연결할 왼쪽 df변수 열이름’, right_on=‘연결할 오른쪽 df변수 열이름’ : 연결할 공통열이름이 다른 경우</li>
<li>indicator = True : 값이 어느 df에 속하는지 표시. _merge 레이블. 값은 양쪽에 포함되면 both, 왼쪽에만 포함되면 left_only, 오른쪽은 right_only</li>
</ul></li>
</ul>
</section>
</section>
<section id="장-날짜-시간" class="level2">
<h2 class="anchored" data-anchor-id="장-날짜-시간">11장 날짜, 시간</h2>
<section id="파이썬-datetime-모듈" class="level3">
<h3 class="anchored" data-anchor-id="파이썬-datetime-모듈">파이썬 datetime 모듈</h3>
<ul>
<li>import datetime as dt</li>
<li>dt.date(연, 월, 일) -&gt; datetime.date 객체 반환</li>
<li>dt.time(시, 분, 초) -&gt; datetime.time 객체 반환. 24시간제. 빈괄호 -&gt; 0시 0분 0초</li>
<li>dt.datetime(연, 월, 일[, 시, 분, 초])</li>
<li>dt.timedelta() : 총 시간 반환</li>
</ul>
</section>
<section id="판다스-timestamp-객체" class="level3">
<h3 class="anchored" data-anchor-id="판다스-timestamp-객체">판다스 Timestamp 객체</h3>
<ul>
<li>pd.Timestamp(연, 월, 일[, 시, 분, 초])</li>
<li>다양한 입력 허용(eg. 문자열): pd.Timestamp(‘2022-01-31’), pd.Timestamp(‘2022/01/31’), pd.Timestamp(‘01/31/2011’) 등</li>
<li>dt.datetime 입력 가능</li>
<li>DatetimeIndex : Timestamp 객체를 저장하는 인덱스</li>
<li>다양한 비교 연산 가능: pd.Timestamp(‘2022-01-31’) &lt; pd.Timestamp(‘2022-02-31’) -&gt; True</li>
<li><strong>특정 열을 날짜/시간 유형으로 변환</strong>: df변수[‘날짜열이름’] = pd.to_datetime(df변수[‘날짜열이름’])</li>
</ul>
</section>
<section id="datetimeproperties-객체" class="level3">
<h3 class="anchored" data-anchor-id="datetimeproperties-객체">DatetimeProperties 객체</h3>
<ul>
<li>날짜/시간 시리즈는 DatetimeProperties 객체에 접근할 수 있는 특별한 속성 <strong>dt</strong>를 가짐: df변수[‘날짜열이름’].dt.day -&gt; 날짜만 표시</li>
<li>요일 숫자로 출력: df변수[‘날짜열이름’].dt.dayofweek -&gt; 0부터 월요일</li>
<li>요일 문자로 출력(영문): df변수[‘날짜열이름’].dt.day_name()</li>
<li>월을 문자로 출력(영문): df변수[‘날짜열이름’].dt.month_name()</li>
<li>행의 날짜가 각 분기의 시작일과 같으면 True 반환: df변수[‘날짜열이름’].dt.is_quarter_start</li>
<li>행의 날짜가 각 분기의 마지막 날과 같으면 True 반환: df변수[‘날짜열이름’].dt.is_quarter_end</li>
<li>df변수[‘날짜열이름’].dt.is_month_start, df변수[‘날짜열이름’].dt.is_month_end, df변수[‘날짜열이름’].dt.is_year_start, df변수[‘날짜열이름’].dt_is_year_end</li>
</ul>
</section>
<section id="일정-시간의-덧셈과-뺄셈-dateoffset" class="level3">
<h3 class="anchored" data-anchor-id="일정-시간의-덧셈과-뺄셈-dateoffset">일정 시간의 덧셈과 뺄셈 DateOffset</h3>
<ul>
<li>날짜에 지정한 날짜/시간만큼 더하기: df변수[‘날짜열이름’] + pd.DateOffset( years=1, months=3, days=5, hours=6, minutes=3)</li>
<li>초, 마이크로초, 나노초도 지원</li>
<li>월별로 일수가 다른 경우 동적으로 날짜 덧셈/뺄셈(eg. 다음 달 말일): df변수[‘날짜열이름’] + pd.offsets.MonthEnd()</li>
<li>이전 달 말일로 이동: df변수[‘날짜열이름’] - pd.offsets.MonthEnd()</li>
<li>다음 달의 첫째 날로 이동. df변수[‘날짜열이름’] + pd.offsets.MonthBegin()</li>
<li>이전 달의 첫째 날로 이동. df변수[‘날짜열이름’] - pd.offsets.MonthBegin(). 주의!! 1일은 이전 달의 1일로 이동</li>
<li>비즈니스 관련 날짜: BMonthEnd() 해당 월의 마지막 영업일</li>
<li><a href="https://pandas.pydata.org/docs/reference/offset_frequency.html" target="_blank">pd.offsets 모듈 공식문서</a></li>
</ul>
</section>
<section id="timedelta-객체" class="level3">
<h3 class="anchored" data-anchor-id="timedelta-객체">Timedelta 객체</h3>
<ul>
<li>한 Timestamp - 다른 Timestamp -&gt; Timedelta 반환</li>
<li>pd.Timedelta( days=8, hours=7, minutes=6, seconds=5 )</li>
<li>pd.to_timedelta(‘3 hours, 5 minutes, 12 seconds’) : 시간을 나타내는 문자열을 인수로 전달
<ul>
<li>unit=‘hour’/‘day’/… : 숫자가 나타내는 시간 단위 정의 pd.to_timedelta(5, unit=‘hour’)</li>
<li>pd.to_timedelta([10, 20, 30], unit=‘day’) : 여러 시간차를 인수로 전달</li>
</ul></li>
<li>df변수[‘날짜열이름’].sort_values(), df변수[‘날짜열이름’].max(), df변수[‘날짜열이름’].min(), df변수[‘날짜열이름’].mean()</li>
<li>1년 넘게 걸린 기간만 필터링 : df변수[‘Timedelta변수’] &gt; pd.Timedelta(days=365)</li>
<li>2000일, 8시간, 4분 보다 오랜 기간 필터링 : df변수[‘Timedelta변수’] &gt; “2000 days, 8 hours, 4 minutes”</li>
<li>각 요일의 날짜를 월요일의 날짜로 변환: bike[‘날짜열이름’] - pd.to_timedelta(bike[‘날짜열이름’].dt.day_of_week, unit=‘day’)
<ul>
<li>요일을 나타내는 숫자(day_of_week)는 월요일(0)로부터 떨어진 일수로 생각할 수 있음.</li>
<li>따라서 현재 날짜에서 월요일로부터 떨어진 일수를 빼면 월요일 날짜를 구할 수 있다.</li>
</ul></li>
</ul>
</section>
</section>
<section id="가져오기-내보내기" class="level2">
<h2 class="anchored" data-anchor-id="가져오기-내보내기">가져오기, 내보내기</h2>
<section id="json" class="level3">
<h3 class="anchored" data-anchor-id="json">json</h3>
<ul>
<li>json 가져오기: pd.read_json(‘json파일명’)</li>
<li>pd.json_normalize(data=df변수[‘키’], record_path=‘하위레코드를 갖는 키’, meta=[‘최상위 키’, ‘최상위 키’, …])</li>
<li>키가 없는 딕셔너리가 있는 경우 위 명령에 에러가 발생한다. 그래서 setdefalut()로 키를 설정한 뒤 apply() 이용하여 df에 적용한다.</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_default_key(entry):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    entry.setdefault(<span class="st">'키가 없는 딕셔너리의 상위키'</span>, [])</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>df변수[<span class="st">'최상위 키'</span>].<span class="bu">apply</span>(add_default_key)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ul>
<li>json 내보내기: df변수.to_json(‘저장할json파일명’)
<ul>
<li>orient=‘records’ : 행 순서대로 키(열이름)-값(데이터)으로 구성된 json 배열 반환</li>
<li>orient=‘split’ : ’컬럼명 키, 인덱스 키, 데이터 값’으로 구성된 json 배열 반환</li>
<li>이 외에도 index, columns, values, table</li>
</ul></li>
</ul>
</section>
<section id="csv" class="level3">
<h3 class="anchored" data-anchor-id="csv">csv</h3>
<ul>
<li>df변수.to_csv(‘저장할 파일명’, index=False): 쉼표로 셀 구분, 줄바꿈 문자로 행 구분</li>
</ul>
</section>
<section id="excel" class="level3">
<h3 class="anchored" data-anchor-id="excel">excel</h3>
<ul>
<li>pd.read_excel(‘파일명’, sheet_name=None) : 모든 시트 가져오기</li>
</ul>
</section>
</section>
<section id="장-시각화" class="level2">
<h2 class="anchored" data-anchor-id="장-시각화">14장 시각화</h2>
<ul>
<li>colormaps 이름 출력: print(plt.colormaps())</li>
</ul>
</section>
<section id="fake-데이터프레임-만들기" class="level2">
<h2 class="anchored" data-anchor-id="fake-데이터프레임-만들기">fake 데이터프레임 만들기</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> fake</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>faker <span class="op">=</span> fake.Faker()</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> [</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    {<span class="st">'name'</span>: fake.name(),</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>     <span class="st">'company'</span>: fake.company(),</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>     <span class="st">'phone'</span>: fake.phone_number(),</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>     <span class="st">'salary'</span>: np.random.randint(<span class="dv">50000</span>, <span class="dv">200000</span>)} <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1000</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(data <span class="op">=</span> data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>