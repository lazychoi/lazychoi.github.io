---
title: "10장 Spanning Tree & Kruskal Algorithm p280"
date: 2022-11-01
---

**신장 트리(Spanning Tree)**란 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미한다. **최소 신장 트리 알고리즘**은 최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘으로 **크루스칼 알고리즘(Kruskal Algorithm)**이 대표적이다.

크루스칼 알고리즘의 핵심 원리 = 가장 거리가 짧은 간선부터 차례로 집합에 추가

트리에 포함되는 간선의 개수 = 노드 개수 - 1

## 알고리즘

1. 간선 데이터를 비용에 따라 오름차순으로 정렬
2. 간선을 하나씩 확인하며 사이클 없으면 최소 신장 트리에 포함


## 구현

1. 변수 선언
    1. 부모 테이블 리스트 변수: 노드 개수 + 1 (인덱스 0 제외하기 위해)
    2. 간선 리스트 변수: 그래프 모양 정보 [[비용, 노드, 노드], ...]
    3. 최종 비용 수치 변수
2. 부모 테이블 변수에서 부모를 자신으로 초기화
3. 간선 리스트를 비용순으로 정렬
4. 연결된 두 노드(간선)를 하나씩 확인하며 사이클이 발생하지 않는 경우에만 집합에 포함
    1. 루트 노드는 자기 자신을 부모로 갖기 때문에 부모 테이블의 인덱스가 자신을 부모로 갖지 않으면(parent[x] != x) 부모 노드를 인자로 입력하여 재귀적으로 호출하면 부모를 알 수 있다.
    2. 부모가 같지 않으면 부모 인덱스가 작은 쪽을 부모로 하여 두 원소가 속한 집합을 합친다.
    3. 집합을 합칠 때마다 간선 비용을 최종 비용 수치 변수에 합친다.
5. 최종 비용 출력

```{mermaid}
graph LR
  1(1)--29---2(2)
  1(1)--75---5(5)
  2(2)--35---3(3)
  2(2)--34---6(6)
  3(3)--7---4(4)
  4(4)--23---6(6)
  4(4)--13---7(7)
  7(7)--25---6(6)
  5(5)--53---6(6)
```

```{python}
# 루트 노드 찾기
def find_parent(parent, x):
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return parent[x]

# 간선으로연결된 두 노드가 속한 집합 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

v, e = 7 ,9
# 그래프 [비용, 노드, 노드] 순
edges = [[29, 1, 2], [75, 1, 5], [35, 2, 3], [34, 2, 6], [7, 3, 4],
         [23, 4, 6], [13, 4, 7], [53, 5, 6], [25, 6, 7]]

parent = [0] * (v + 1)
for i in range(1, v + 1):
    parent[i] = i

min_cost = 0

# 그래프를 비용 순으로 정렬(오름차순)
edges.sort()

# 그래프의 간선을 돌며 사이클 확인
for edge in edges:
    cost, a, b = edge
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        min_cost += cost

print(min_cost)
```
